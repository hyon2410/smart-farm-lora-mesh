#include <SPI.h>
#include <LoRa.h>
#include <DHT.h>

// C·∫•u h√¨nh c·∫£m bi·∫øn DHT11
#define DHT_PIN 15
#define DHTTYPE DHT11
DHT dht(DHT_PIN, DHTTYPE);

// C·∫•u h√¨nh ch√¢n
#define SOIL_MOISTURE_A0_PIN 35
#define LIGHT_SENSOR_PIN 34
#define PUMP_PIN 25
#define LIGHT_PIN 26

// C·∫•u h√¨nh LoRa
#define LORA_SS 5
#define LORA_RST 14
#define LORA_DIO0 2
#define LORA_BAND 433E6

// ID c·ªßa c√°c node
#define SLAVE_ID 1
#define RELAY_ID 2
#define GATEWAY_ID 3

void sendData(const String &data, int dst);

void setup() {
    Serial.begin(115200);
    pinMode(PUMP_PIN, OUTPUT);
    pinMode(LIGHT_PIN, OUTPUT);
    digitalWrite(PUMP_PIN, LOW);
    digitalWrite(LIGHT_PIN, LOW);

    dht.begin();
    LoRa.setPins(LORA_SS, LORA_RST, LORA_DIO0);
    if (!LoRa.begin(LORA_BAND)) {
        Serial.println("‚ùå LoRa init failed!");
        while (1);
    }

    // T·ªëi ∆∞u h√≥a LoRa
    LoRa.setTxPower(20); // C√¥ng su·∫•t t·ªëi ƒëa (20 dBm)
    LoRa.setSpreadingFactor(7); // Y·∫øu t·ªë tr·∫£i ph·ªï (7-12, 7 l√† c√¢n b·∫±ng)
    LoRa.enableCrc(); // B·∫≠t ki·ªÉm tra CRC

    Serial.println("üöÄ Node 1 (SLAVE) Ready!");
}

void loop() {
    static unsigned long lastSendTime = 0;
    const unsigned long sendInterval = 10000; // G·ª≠i m·ªói 10 gi√¢y

    // ∆ØU TI√äN X·ª¨ L√ù L·ªÜNH
    int packetSize = LoRa.parsePacket();
    if (packetSize) {
        String receivedData = "";
        while (LoRa.available()) {
            receivedData += (char)LoRa.read();
        }
        Serial.printf("[%lu] üì• Received: %s\n", millis(), receivedData.c_str());

        // Ki·ªÉm tra senderID v√† receiverID tr∆∞·ªõc
        int senderID, receiverID;
        int result = sscanf(receivedData.c_str(), "%d,%d", &senderID, &receiverID);
        if (result < 2) {
            Serial.printf("[%lu] ‚ö†Ô∏è Invalid packet format: %s\n", millis(), receivedData.c_str());
            return;
        }

        // Ch·ªâ x·ª≠ l√Ω n·∫øu senderID=RELAY_ID v√† receiverID=SLAVE_ID
        if (senderID != RELAY_ID || receiverID != SLAVE_ID) {
            Serial.printf("[%lu] ‚ö†Ô∏è Ignoring packet: sender=%d, receiver=%d, expected sender=%d, receiver=%d\n",
                          millis(), senderID, receiverID, RELAY_ID, SLAVE_ID);
            return;
        }

        // Ph√¢n t√≠ch l·ªánh
        int command;
        result = sscanf(receivedData.c_str(), "%d,%d,%d", &senderID, &receiverID, &command);
        if (result != 3) {
            Serial.printf("[%lu] ‚ö†Ô∏è Failed to parse command: %s\n", millis(), receivedData.c_str());
            return;
        }

        Serial.printf("[%lu] ‚úÖ Valid command from Relay: %d\n", millis(), command);
        // X·ª≠ l√Ω l·ªánh
        switch (command) {
            case 1:
                digitalWrite(LIGHT_PIN, HIGH);
                Serial.printf("[%lu] ‚úÖ ƒê√®n B·∫¨T (LIGHT_PIN=%d)\n", millis(), digitalRead(LIGHT_PIN));
                break;
            case 2:
                digitalWrite(LIGHT_PIN, LOW);
                Serial.printf("[%lu] ‚úÖ ƒê√®n T·∫ÆT (LIGHT_PIN=%d)\n", millis(), digitalRead(LIGHT_PIN));
                break;
            case 3:
                digitalWrite(PUMP_PIN, HIGH);
                Serial.printf("[%lu] ‚úÖ M√°y b∆°m B·∫¨T (PUMP_PIN=%d)\n", millis(), digitalRead(PUMP_PIN));
                break;
            case 4:
                digitalWrite(PUMP_PIN, LOW);
                Serial.printf("[%lu] ‚úÖ M√°y b∆°m T·∫ÆT (PUMP_PIN=%d)\n", millis(), digitalRead(PUMP_PIN));
                break;
            default:
                Serial.printf("[%lu] ‚ö†Ô∏è Unknown command: %d\n", millis(), command);
                break;
        }
    }

    // G·ª¨I D·ªÆ LI·ªÜU C·∫¢M BI·∫æN
    unsigned long currentTime = millis();
    if (currentTime - lastSendTime >= sendInterval) {
        // ƒê·ªçc c·∫£m bi·∫øn
        float temp = dht.readTemperature();
        float hum = dht.readHumidity();
        int soilRaw = analogRead(SOIL_MOISTURE_A0_PIN);
        int lightRaw = analogRead(LIGHT_SENSOR_PIN);

        // Ki·ªÉm tra l·ªói c·∫£m bi·∫øn
        if (isnan(temp) || isnan(hum)) {
            temp = -999.0; // Gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu l·ªói
            hum = -999.0;
            Serial.printf("[%lu] ‚ö†Ô∏è DHT11 read failed!\n", millis());
        }

        // Chuy·ªÉn ƒë·ªïi sang ph·∫ßn trƒÉm
        int soilPercent = map(soilRaw, 4095, 2500, 0, 100);
        int lightPercent = map(lightRaw, 4095, 0, 0, 100);

        // Gi·ªõi h·∫°n gi√° tr·ªã trong kho·∫£ng 0-100
        soilPercent = constrain(soilPercent, 0, 100);
        lightPercent = constrain(lightPercent, 0, 100);

        // T·∫°o chu·ªói d·ªØ li·ªáu
        String data = String(SLAVE_ID) + "," + String(RELAY_ID) + "," + String(millis()) + "," +
                      String(temp, 2) + "," + String(hum, 2) + "," + String(soilPercent) + "," + String(lightPercent);

        sendData(data, RELAY_ID);
        Serial.printf("[%lu] üì§ Sent to %d: %s\n", millis(), RELAY_ID, data.c_str());
        Serial.printf("[%lu] Temp: %.2f¬∞C | Hum: %.2f%% | Soil: %d%% | Light: %d%%\n",
                      millis(), temp, hum, soilPercent, lightPercent);

        lastSendTime = currentTime;
    }
}

void sendData(const String &data, int dst) {
    LoRa.beginPacket();
    LoRa.print(data);
    LoRa.endPacket();
    Serial.printf("[%lu] üì§ LoRa Sent: %s\n", millis(), data.c_str());
}